**Chall**
```Python
from Crypto.Util.number import *
e = 65537
flag = b'KCSC{s0m3_r3ad4ble_5tr1ng_like_7his}'
def reverse(n):{
    #function to reverse binary of n
}

while True:
    p = getPrime(1024)
    q = inverse(e, p)
    if not isPrime(q):
        continue
    n = p * q
    cipher = pow(bytes_to_long(flag),e,n)
    n = reverse(n) 
    f = open('output.txt','w')
    print(f"N = {n}",file=f)
    print(f"e = {e}",file=f)
    print(f"Cipher = {cipher}",file=f)
```
-------
**Solve**
- Sau khi đọc code trên ta thu được thông tin như sau:
  ![image](https://github.com/Caycon/KCSC.TTV/assets/97203151/58295edd-3908-48cd-a3c1-d8b1cb7d0857)
- Giờ ta tiến hành tìm p theo k bằng source code sau:
```Python
from gmpy2 import *

def solve_quadratic(a, b, c):
    delta = mpz(b**2) - 4*mpz(a)*mpz(c)
    if delta < 0:
        return None
    sqrt_delta = gmpy2.isqrt(delta)
    x1 = int(-mpz(b) + sqrt_delta) // (2*mpz(a))
    x2 = int(-mpz(b) - sqrt_delta) // (2*mpz(a))
    return x1, x2

n = mpz("13524733362044232010736349595937464796777752381282044858904535549598695415259485540306280531287404403541039855661018351433654227342950710134306170544748441173774593898898768923907735212448495520658645896437678387670188401560165044043577269969416130117140222729708904953465161496726313677920240975640999580444678641072701612002184731572732086781180661428229265121878536891979130796853074814897843058889565035037987946761236280609366824566706376823708457581218333217098354233306312287549927586100725051273954453617494755601749327688591032955254157726764321151877093977335572150146339853526534429133266975640029987854181")
e = 65537
Cipher = 3678620397255743852788853741107986108860981676309723331641730290544731009447106060307185476663548386172571801713658668783790148410569386488760778490944114348420614589196065297281576228195492339713201469195237426515519163981864121592862248581092535664172672153903696701157467812876812796524706730400133900257530235932000707810825149259236944828592989457788651053131965278448678769098840150302476398856999420129829083563611916558475165369663734941095660119099130765405955767410469621006246831917091632524062249541513097151767121519911807673852738866453379562168834013804186606786287157327927655505568604704262776577804

k = 1
while k <= 99999:
    a = k
    b = 1
    c = -e * n
    p1, p2 = solve_quadratic(a, b, c)

    if is_divisible(n, p1) and len(str(p1)) == 309:
        print("Found prime p:", p1)
        print(n % p1)
        break

    if is_divisible(n, p2) and len(str(p2)) == 309:
        print("Found prime p:", p2)
        print(n % p2)
        break

    k += 1
```
- Tuy nhiên các bạn sẽ không tìm được p nếu các bạn bỏ qua hàm `n = reverse(n) ` của chall:((
- Do đó bạn cần reverse lại n trước khi tìm p bằng code sau:
```Python
def reverse(n):
    reversed_n = 0
    while n > 0:
        reversed_n = (reversed_n << 1) | (n & 1)
        n = n >> 1
    return reversed_n

def reverse_inverse(reversed_n):
    original_n = reverse(reversed_n)
    return original_n
n = 13524733362044232010736349595937464796777752381282044858904535549598695415259485540306280531287404403541039855661018351433654227342950710134306170544748441173774593898898768923907735212448495520658645896437678387670188401560165044043577269969416130117140222729708904953465161496726313677920240975640999580444678641072701612002184731572732086781180661428229265121878536891979130796853074814897843058889565035037987946761236280609366824566706376823708457581218333217098354233306312287549927586100725051273954453617494755601749327688591032955254157726764321151877093977335572150146339853526534429133266975640029987854181
reversed_n = reverse(n)
original_n = reverse_inverse(reversed_n)

print("Original:", n)
print("Reversed:", reversed_n)
```
- Sau khi tìm được p ta tiến hành tìm flag theo RSA như bth:
```Python
from Crypto.Util.number import *
N = 10535928993957098707495868629894329792474452627850484364879975170776044359523502316712812160652468895360539480661909481847699725994424302337527894003647493404319479822948801135582064759413675137973329275363323307322700057229292876616227464768042846058603605698411497986428096602564579426872208940723176671431481552210121834864189396919386160623517904031927997144164227315481061780852236992136682820486583286833470123275605460358511115809814429237942992178881673308811386879602517751325668987352562850689002557168152549671137879638365209684530796460734176686377930364792278724956593791041667923647224672406278328787563
e = 65537
Cipher = 3678620397255743852788853741107986108860981676309723331641730290544731009447106060307185476663548386172571801713658668783790148410569386488760778490944114348420614589196065297281576228195492339713201469195237426515519163981864121592862248581092535664172672153903696701157467812876812796524706730400133900257530235932000707810825149259236944828592989457788651053131965278448678769098840150302476398856999420129829083563611916558475165369663734941095660119099130765405955767410469621006246831917091632524062249541513097151767121519911807673852738866453379562168834013804186606786287157327927655505568604704262776577804
p= 106245478298766053336506937865696693518495671128140728235840143567858412848196219487107562730423460350636088499018940205376906326308245092147076762614122387487384071498893733389141981647735797413890130062601671192092533177585198005584601980589160823077821937079776813122221838761636244752593026992533381924761
q= N//p
phi= (p-1)*(q-1)
d= pow(e, -1, phi)
m= pow(Cipher,d,N)
print(d)
print(q)
print(long_to_bytes(m))
```
